# 初始化列表

-------

## 1. 来源

在 **C++98** 中，采用 **花括号{}** 进行初始化的只有 **数组元素** ，对于其他一些类型不可使用列表进行初始化。

比如：

``` C++
//数组元素进行初始化
int array[] = {1, 2, 3, 4, 5};
int array1[5] = {0}; 

//其他内置类型以及自定义类型无法采用列表初始化
vector<int> v{1, 2, 3, 4, 5};
vector<int> v1 = {1, 2, 3}
```

对于其他内置类型无法采用列表进行初始化，导致要对其进行初始化时，必须先将其定义出来在采用 **循环对其进行赋值** ，从而达到初始化的目的。

C++11扩大了用 **大括号列表** 的适用范围，使内置类型和用户自定义类型均可使用。

【注意】： **列表进行初始化时，可添加等号(=)，也可不添加等号**，其效果是一样的 

## 2. 初始化列表

### 2.1 内置类型的列表初始化

``` C++
#include <iostream>
#include <vector>
#include <map>

int main()
{
    //内置类型
    int x = {10};
    int x1{11};
    int x2 = {1 + 2};
    char c{'y'};
    char c1{'k'};
    
    //动态数组
    int* arr = new int[5]{1, 2, 3, 4, 5};

    //容器
    std::vector<int> v{1, 2, 3, 4, 5};
    std::map<int, int> mp{{1,2}};
    return 0;
}
```

### 2.2 自定义类型的列表初始化

``` C++
#include <iostream>

class Base
{
private:
    int a = 0;
    int b = 0;

public:
    Base(int _a = 0, int _b = 0)
        : a(_a)
        , b(_b)
    {}

    void Show()
    {
        std::cout << a << b << std::endl;
    }
};

int main()
{
    Base a{1, 2};
    a.Show();
    return 0;
}
```

对于上面这个例子没有实现自定义类型的初始化列表，这只是对于其进行赋值而已，**{}的作用等同于()**。

**本质：将{}转化为pair或者数据而已，没有列表初始化**

**列表初始化：可以对于一个类型的数据或者类进行连续的赋值，增加数据元素个数。不仅仅只是插入一个数据。**

比如：对于vector容器，可以一次性初始化多个数据

标准模板库中可以对于vector等容器支持列表初始化源自 <initializer_list> 这个头文件中的initializer_list类模板的支持。程序员只要使用了#include <initializer_list> 头文件，并且声明一个以initializer_list <T> 模板类为参数类型的构造函数即可实现自定义类的列表初始化。

**对于函数，类和结构体成员函数均可使用初始化列表**

*代码可以看本文末尾*

## 3. 防止类型收窄

**类型收窄：隐式类型转换导致数据变化或者精度丢失**

常见类型收窄：

1. 从浮点数隐式转换到整数。比如：int a = 1.2，这里a实际保存的是整数1，以视为类型收窄
2. 从整型到浮点型隐式转化。比如：整数达到浮点型无法表示
3. 高精度的浮点型到低精度的浮点型数据。比如：long double到double或者double到float的转换都会导致精度丢失，也判定为类型收窄
4. 整型到低长度的整形。比如：unsinged char = 1024,1024明显不是长度为8的unsigned char所能表示的

**【注意】：如果变量a从类型A到类型B，其值在B中可以被表示，并且从类型B到类型A可以得到原来的值，那么就认为不是类型收窄**

对于类型收窄是有危险的，在C++11，使用初始化列表进行初始化的数据会检查是否发生类型收窄

``` C++
#include <iostream>

/************************************
 * 初始化列表可以检测类型收窄
 * 类型收窄：无法通过编译
 ************************************/ 
int main()
{
    const int x = 1024;
    const int y = 10;
    
    char a = x; //类型收窄，但可以通过编译
    char* b = new char(1024);//类型收窄，但可以通过编译

    char c = { x }; //类型收窄，无法通过编译
    char d = { y }; //可以通过编译，无类型收窄
    unsigned char e { -1 }; //收窄，无法通过编译
    
    float f { 7 }; //可以通过编译
    int g { 2.0f }; // 收窄，无法通过编译
    float* h = new float{1e48}; // 收窄，无法通过编译
    float i = 1.2l; // 可以通过编译

    return 0;
}
```

总结，在C++11中，列表初始化是唯一一种可以**防止类型收窄**的初始化方式。这也是列表初始化不同于其他初始化的地方。

**加强类型使用的安全性**

**改变对类型初始化的方式，是标准程序库和语言更加贴近，有效的统一了内置类型和自定义类型的行为**

C++11设计遵循的思想：**通用为本，专用为末**

【注意】： [本文代码](https://github.com/YKitty/Code/tree/master/C%2B%2BCode/C%2B%2B11/initializer_list )

参考资料：深入理解C++11（书籍）

