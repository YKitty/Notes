# MySql两种引擎的对比

-----------------

## 1. 前言

对于MySql一般普遍的是两种引擎。**MyISAM和InnoDB**这两种，**MyISAM是在5.5.5版本之前**默认使用的，然**InnoDB是5.5.5之后**默认使用的

## 2. 对比

- **事务**

**InnoDB增加了事务处理**，而MyISAM没有事务处理

事务：ACID四种特性

1. 原子性
2. 一致性
3. 隔离性
4. 持久性

- **锁粒度**

InnoDB的锁的粒度小，支持在一个记录上加锁，也就是**行级锁**；但是对于MyISAM仅支持加**表锁**。

InnoDB支持事务和行锁，会带来几个问题：

1. 脏读

脏读顾名思义就是读取的数据已经被污染了。

举例：一个员工从公司系统读取自己的工资从1000变成了8000，开心坏了，结果财务一看改错了，不应该是这个的工资高了，应该是其他人的，然后又该回去了这个时候，这个数据8000就变成了一个脏数据了

2. 不可重复读

不可重复读也就是不能再次读取一个数据。

举例：事务A读取数据i是5，在这个事务还**没有提交之前**，另一个事务将i进行了修改，导致A第二次读取的数据不一致了。

解决方法：在一个事务操作一个数据时，其他事务不能再次操作。也就是互斥即可

3. 幻读

幻读一般是对于表进行操作时，会出现幻读。

第一个事务对一个表中的数据进行了修改，这种修改涉及到表中
的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发
生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

- **索引差异**

InnoDB是聚集索引，而MyISAM是非聚集索引

聚集索引：也就是对于一个索引结点直接就是数据节点，包含了所有的列

非聚集索引：对于索引来说保存的只是数据的地址，不是数据本身

- **count函数**

MyISAM记录着这个表的count，当使用count时，直接返回即可；但是InnoDB没有记录，当要计算时会对整个表进行一次扫描。

【注意】：当有where条件时，两个表的操作都是一样的，都要对整个表进行扫描

- **数据库文件差异**

MyISAM属于**堆表**。在磁盘上有**三个文件，每个文件名以表名开头，扩展名指出文件类型。**

1.   .frm用于存储表的定义
2.   .MYD用于存储数据
3.   .MYI用于存储表索引

MyISAM还支持**三种不同的存储格式**：

1. 静态表
2. 动态表
3. 压缩表

InnoDB属于**索引组织表**。共享表空间存储和多表空间存储

两种存储方式的表结构和MyISAM一样，以表名开头，扩展名是.frm。

如果使用共享表空间，那么所有表的数据文件和索引文件都保存在一个表空间里，一个表空间可以有多个文件，通过innodb_data_file_path和innodb_data_home_dir参数设置共享表空间的位置和名字，一般共享表空间的名字叫ibdata1-n。

如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。

- **主键**

MyISAM允许没有任何索引和主键的表存在，MyISAM保存的索引都是**记录的地址**；InnoDB如果没有设定主键或者非空唯一索引，就会自动生成一个**6字节的默认主键**，InnoDB的主索引保存的是**数据**。

- **自动增长列**

**MyISAM自动增长列**必须是索引，如果是组合索引，自动增长可以**不是第一列**；**InnoDB自动增长列**必须是索引，如果是组合索引也必须是**组合索引的第一列**。

**InnoDB必须有一个只有自动增长列的单独索引**

- **全文索引**

MyISAM支持FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是InnoDB可以使用sphinx插件支持全文索引，并且效果更好。

- **delete from table**

使用这条命令InnoDB不会重新建立新表，而是一条条的删除数据，在InnoDB上如果要清空大量数据，推荐使用**truncate table**（需要drop权限）

- **索引位置**

MyISAM索引以表名+.MYI文件分别保存；InnoDB的索引和数据一起保存在表空间

- **外键**

MyISAM不支持外键；InnoDB支持外键

