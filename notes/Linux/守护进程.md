# 守护进程

---

##  1.概念 

> - 守护进程也叫作**精灵进程**，是**运行在后台**的一种特殊进程。他**独立于控制终端并且周期性的执行或者等待处理某些发生的事件。**
> - **守护进程是一种生存周期长的进程。**
>
> **【注意】**：**守护进程没有控制终端**



## 2. 如何查看守护进程

> - 对于守护进程，可以采用**`ps -axj | grep mydaemon`**命令进行查看
> - 一般看到的守护进程其父进程都是**1号进程**
> - 使用**`ps -axj | grep mydaemon`**查看守护进程之后，可以查看守护进程的pid
> - 然后使用命令**`cd /proc/pid(守护进程的pid)`**进入到该守护进程的proc进程文件信息中，然后使用**`ls -al`**就可以看到守护进程是工作与那个目录下的。
> - 有一个**参数是cwd(current work directory)就是当前工作目录**，然后就可以看到**该守护进程是在那个目录下工作的了**
>   - 形式：**`cwd -> /`**
>   - **`cwd -> /home/yk/LinuxDir/LinuxCode/process`**
> - 还有一个**参数是exe表示执行文件**，在那个工作目录下
>   - 形式：**`exe -> /home/yk/LinuxDir/LinuxCode/process/mydaemon`**
>
> **【扩展】**
>
> - 对于守护进程的工作目录可以改变，但是对于守护进程的执行文件的目录一般不会改变
>
> - **改变工作目录**
>
>   - 使用**系统调用函数chdir()**
>
>   - ```
>     #include <unistd.h>
>     
>     int chdir(const char* path);
>     int fchdir(int fd);
>     
>     返回值：
>     	成功返回0，失败返回-1，并且失败会适当的设置errno
>     ```
>
>   - 对于这两个函数，
>
>     - **chdir()将调用进程的当前工作目录改为路径中指定的目录**
>     - **fchdir()与chdir()相同；惟一的区别在于目录是作为打开的文件描述符给出的**
>
> **【重点】**
>
> - **守护进程都是孤儿进程**
> - **守护进程没有控制终端**
>   - 对于其他进程都是在用户登录或者运行程序的时候创建的，在运行结束或者用户注销的时候终止，但是**守护进程不受用户登录注销的影响**
> - **守护进程运行在后台，他独立于控制终端并且周期性的执行某种任务或者等待处理某些发生的事件**



## 3. 创建守护进程

>  - 第一种方法：
>
>  - **使用setsid函数创建一个新的Session，并成为Session Leader**
>
>  - ``` c++
>    #include <unistd.h>
>    
>    pid_t setsid(void);
>    
>    返回值：
>    	调用成功时返回新创建的Session的id（其实也就是当前进程的id），出错返回-1
>    ```
>
>  - **【注意】**
>
>    - **调用这个函数之前，当前进程不允许是进程组的Leader，否则该函数失败返回-1**
>      - 要保证当前进程不是进程组的Leader其实也很容易，只要先fork其次退出父进程在调用setsid就行了。fork创建的子进程和父进程在同一个进程组中，进程组的Leader必然是该组的第一个进程，所以子进程不可能是该组的第一个进程，在子进程中调用setsid就不会有问题了
>    - 必须要将**umask设置为0**，为了可以**创建文件具有权限**
>    - 忽略SIGCHID信号
>    - 将当前目录改**`/`**目录，关闭不在需要的文件描述符，或者将其重定向到/dev/null
>
>  - 第二种方法：
>
>  - 调用**daemon()函数**
>
>  - ``` c++
>    #include <unistd.h>
>    
>    int daemon(int nochdir, int noclose);
>    ```
>
>  - **如果nochdir是0的话，则表示不需要改变当前的工作目录，该守护进程的工作目录是该目录，否则将其改变为根目录下**
>
>  - **如果noclose是0的话，则表示不关闭文件描述符，将其重定向到/dev/null。否则的关闭0,1,2文件描述符**





## 4. 知识扩展

> 使用**`ps -axj`**可以打印系统中各个进程的状态
>
> - **`-a`**：显示其他用户所拥有的进程的状态
> - **`-x`**：显示没有控制终端的进程状态
> - **`-j`**：显示与作业有关的信息
>   - 会话ID
>   - 进程组ID
>   - 控制终端
>   - 终端进程组ID
>
> ![](https://ykitty.oss-cn-beijing.aliyuncs.com/photo/Linux/%E5%91%BD%E4%BB%A4/ps%20-axj.png "ps命令")
>
> 对于该图片按照顺序：各标题的意义分别是：
>
> - PPID：父进程ID
> 	 PID：进程ID	
> 	 PGID：进程组ID		
> - SID：会话ID（会话首进程的进程ID）
> - TTY：终端名 
> - UID：用户ID
> 	 COMMAND：命令字符串	
>
> **【要点】**
>
> - **父进程ID为0的各进程通常都是内核进程，他们作为系统引导装入过程的一部分而启动。**
> - **内核进程是特殊的，通常存在于系统的整个生命周期中**，他们以**超级用户特权运行，无控制终端，无命令行**
> - 在**ps的输出实例中**，**内核守护进程的名字出现在方括号**中
> - **内核守护进程**的**会话ID全都是一个会话ID**
>   - **会话ID**（会话首进程的进程ID）
>     - 会话首进程：创建该会话的进程
>   - **会话ID是0**
>   - **0是所有内核进程的父进程**
>
> 