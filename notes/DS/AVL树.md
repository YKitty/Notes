# AVL树

----------

## 1. 来源

**二叉搜索树**虽说可以**缩短查找的效率**，但是如果数据有序或者接近有序的话将会退化为**单支树**，查找元素的效率和顺序查找一样，效率低下。

两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法：**当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树的高度之差不超过1（需要对树中的结点进行调整），即可降低树的高度，从而减少平均搜索长度**

## 2. 定义

AVL树：

- **左右子树都是AVL树**
- **左右子树的高度差(平衡因子)的绝对值不超过1**

如果一个二叉搜索树是高度平衡的，那他就是AVL树。如果其有n个结点，则高度即可保持在log2(N + 1)

![](https://ykitty.oss-cn-beijing.aliyuncs.com/photo/DS/AVL/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6.png)

**查找的时间复杂度：O(log2N)**

## 3. 优缺点

查找效率稳定并且效率高，但构造AVL树比较费力

## 4. 实现

### 4.1 设计AVL树结点

对于AVL树由于在进行插入数据时，需要调整树的结构，因此设计为**三叉链结构**

``` C++
template<class K, class V>
struct AVLTreeNode 
{
  struct AVLTreeNode<K, V>* _left;
  struct AVLTreeNode<K, V>* _right;
  struct AVLTreeNode<K, V>* _parent;

  K _key;
  V _value;
  int _bf;//平衡因子
  AVLTreeNode(const K& k, const V& v):_key(k),_value(v),_bf(0),_left(nullptr),_right(nullptr),_parent(nullptr)
  {}
};
```

**_bf对于bf是平衡因子也就是左右子树的高度差**

**_bf = 右子树高度 - 左子树高度**

### 4.2 AVL树插入数据

对于AVL插入数据时，有**两步**

- **按照二叉搜索树进行插入数据**
- **对于AVL进行调整平衡因子**



### 4.3 AVL树的旋转

对于AVL的旋转有着**四种旋转**

- **左单旋**
- **右单旋**
- **左右双旋**
- **右左双旋**

### 4.4 AVL树的验证

两步验证：

- 验证是不是二叉搜索树（进行中序遍历）
- 验证每一个结点的平衡因子

### 4.5 AVL树的性能

AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这样可以保证查询时高效的时间复杂度，即log2(N)。但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。
因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修改，就不太适合。























