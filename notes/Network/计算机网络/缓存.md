# 缓存

- [1.  缓存穿透](#1--缓存穿透)
    - [1. 1 概念](#1-1-概念)
    - [1.2 问题](#12-问题)
    - [1.3 解决](#13-解决)
        - [1.3.1 缓存空值](#131-缓存空值)
        - [1.3.2 BloomFilter](#132-bloomfilter)
- [2. 缓存击穿](#2-缓存击穿)
    - [2.1 概念](#21-概念)
    - [2.2 问题](#22-问题)
    - [2.3 解决](#23-解决)
- [3. 缓存雪崩](#3-缓存雪崩)
    - [3.1 概念](#31-概念)
    - [3.2 问题](#32-问题)
    - [3.3 解决](#33-解决)
        - [3.3.1 事前预防](#331-事前预防)
        - [3.3.2 事中解决](#332-事中解决)
        - [3.3.3 事后解决](#333-事后解决)
- [4. 解决热点数据其中失效的问题](#4-解决热点数据其中失效的问题)
    - [4.1 解决](#41-解决)
        - [4.1.1 设置不同的失效时间](#411-设置不同的失效时间)
        - [4.1.2 互斥锁](#412-互斥锁)

-----------

## 1.  缓存穿透

### 1. 1 概念

缓存穿透就是当客户端访问数据的时候，访问的是一个不存在的数值，在缓存中一定找不到，就会每次都到数据库中查找，导致效率低下

### 1.2 问题

黑客那一个不存在的ID去进行大量查询，每次都到数据库中查询数据，有可能导致数据压力过大而宕机

### 1.3 解决

### 1.3.1 缓存空值

之所以会出现缓存击穿是因为缓存中没有空数据的key，导致每次查询的时候都要到数据库中进行查询。

因此，我们可以对于这些不存在的key，在缓存中将其对应的value设置为null，请求这个key时，直接返回null就不需要到数据库中去了。对于**这些数据一定要设置过期时间**

### 1.3.2 BloomFilter

使用布隆过滤器，可以加在第一种解决方案之前，对于每个数据到来时，首先到布隆过滤器中查询一下，看是否存在，存在再去缓存中查找，否则直接返回null。

## 2. 缓存击穿

### 2.1 概念

缓存击穿就是同时有大量请求同时请求一个key，而此时这个key刚好失效了，导致都到数据库中获取信息。

### 2.2 问题

导致数据库压力剧增，有可能宕机

### 2.3 解决

当有多个数据到数据库中查询同一个数据时，我们可以进行加锁操作，对第一个请求加锁，导致后面的请求只能等着请求结束拿到锁了之后，才可以再次访问。

第一个数据查询到了数据之后放到缓存中，后面进行的请求就可以直接从缓存中拿取数据了

## 3. 缓存雪崩

### 3.1 概念

缓存雪崩有三种情况，一：服务器刚开始运行还没有缓存数据，此时有大量请求；二：大量缓存同时失效‘三：服务器宕机

### 3.2 问题

导致同时有大量请求到数据库加大数据库的压力

### 3.3 解决

### 3.3.1 事前预防

采用**集群缓存，保证缓存服务的高可用**

比如：采用Redis，使用主从+哨兵，Redis Cluster来避免Redis全盘崩溃的情况

### 3.3.2 事中解决

**ehcache本地缓存+Hystrix限流&降级，避免Mysql被打死**

使用ehcache本地缓存可以防止大量请求直接到数据库上，可以先到本地缓存进行查找

使用Hystrix限流&降级，比如一秒来了5000个请求，我们可以设置一秒只能有2000个请求能通过这个组件，那么剩余的3000个就会走限流逻辑

### 3.3.3 事后解决

- **开启Redis持久化机制，尽快恢复缓存集群**

一旦重启就可以从磁盘上自动加载数据恢复内存中的数据

防止雪崩的方案：

![](https://ykitty.oss-cn-beijing.aliyuncs.com/photo/%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.jpg)

## 4. 解决热点数据其中失效的问题

我们在设置缓存的时候，会给缓存设置一个失效时间，过了这个时间就失效了。

对于一些热点数据，当缓存失效的话，会导致大量请求到数据库上，导致数据库崩溃

## 4.1 解决

### 4.1.1 设置不同的失效时间

为了避免热点数据集中失效，我们在设置缓存过期时间时，可以尽量错开，不在同一个时间段缓存失效。

### 4.1.2 互斥锁

在第一个请求去访问数据库时，其余的请求因为拿不到锁而只能等待直到所释放，保护数据库不会同时有大量请求

但是由于此时会阻塞其他线程导致系统的吞吐量会下降。

