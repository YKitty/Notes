# 乐观锁和悲观锁

- [乐观锁和悲观锁](#乐观锁和悲观锁)
    - [前言](#前言)
    - [1. 并发控制](#1-并发控制)
    - [2. 乐观锁和悲观锁的出现的原因](#2-乐观锁和悲观锁的出现的原因)
    - [3. 乐观锁和悲观锁是什么](#3-乐观锁和悲观锁是什么)
        - [3.1 并发控制机制](#31-并发控制机制)
        - [3.2 悲观并发控制（悲观锁）](#32-悲观并发控制悲观锁)
        - [3.3 乐观并发控制（乐观锁）](#33-乐观并发控制乐观锁)
    - [4. 悲观锁和乐观锁的特点](#4-悲观锁和乐观锁的特点)
        - [4.1 悲观锁](#41-悲观锁)
        - [4.2 乐观锁](#42-乐观锁)
    - [5. 悲观锁和乐观锁的使用场景](#5-悲观锁和乐观锁的使用场景)
        - [5.1 悲观锁](#51-悲观锁)
        - [5.2 乐观锁](#52-乐观锁)
    - [6. 悲观锁和乐观锁的实现方式](#6-悲观锁和乐观锁的实现方式)
        - [6.1 悲观锁实现方式](#61-悲观锁实现方式)
        - [6.2 乐观锁实现方式](#62-乐观锁实现方式)
            - [6.2.1 解决ABA问题](#621-解决aba问题)
    - [7. 悲观锁和乐观锁应该如何选择](#7-悲观锁和乐观锁应该如何选择)
    
---------------------

## 前言

**悲观锁和乐观锁**是两种常见的**资源并发锁**设计思路，也是**并发编程**中的一个基础概念。

本文是以**数据库环境**下进行介绍。

## 1. 并发控制

在**多线程环境下，为了保证线程安全，需要使用并发控制。**

数据库管理系统中有**事务**的概念，它是**一组操作**，并且满足**ACID特性**。一个事务可以看成一组**任务**，而任务是由**线程驱动**的，因此事务也可以并发的执行。并发执行多个事务时，为了保证每个事物都具有ACID特性，也同样需要**并发控制**。

常见的由并发所产生的问题：

- **脏读：** 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，此时，另外一个事务也访问这个数据，然后使用了这个数据

- **不可重复读：** 是指在一个事务内，多次读同一个数据。在这个事务还没有结束时，另外一个事务也访问同一个数据。那么，在第一个事务两次读取数据之间，另外一个事务的修改，那么第一个事务两次读到的数据可能是不一样的。

- **幻读：** 指当事务不是独立执行时发生的一种现象（一般是对于整个表进行了修改）。

  例如：第一个事务对一个表的所有id进行了修改，同时第二个事务也向这个表中插入一行新数据。那么以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就像发生了幻觉一样。

## 2. 乐观锁和悲观锁的出现的原因

为了**解决并发**带来的问题。我们引入了**并发控制**。

主要有两种并发控制方法：**悲观并发控制（悲观锁）和乐观并发控制（乐观锁）**。

## 3. 乐观锁和悲观锁是什么

### 3.1 并发控制机制

**悲观锁：** 假定每次操作时，都会发生并发冲突，每次进行操作时，都会申请锁

**乐观锁：** 假定每次操作时，都不会发生冲突，直接进行操作，操作完成之后进行**冲突检测**，发生冲突，则申请锁重新操作，否则操作成功。

**【注意】：乐观锁不能解决脏读问题**

原因：对于乐观锁操作完成之后，会进行冲突检测，但是这个时候第二事务有可能还**没有进行回滚操作**，所以就无法检测到，**数据是否冲突**

### 3.2 悲观并发控制（悲观锁）

**悲观并发控制**保持**悲观态度**，认为并发执行过程中**一定会出现问题**，一定要对数据进行保护，需要提前申请锁资源，不能同时两个事务对同一个数据进行操作。

因此，**悲观锁**就是每次一个事务在进行操作时一定要先**获得锁资源**然后才能操作数据（临界资源），当没有活的锁资源的时候，就不能对数据进行操作

### 3.3 乐观并发控制（乐观锁）

**乐观并发控制**保持**乐观态度**，认为在并发过程中**一般都不会出现问题**，可以**直接对数据进行操作**，不需要提前申请锁资源。

但是对于乐观锁有着一个机制就是每次对于数据操作完成之后不会立即对于操作的数据进行提交，会经过一个**检测过程**。

**检测过程：**对于数据修改之后，会将**旧数据和现内存中的数据进行比较**，如果数据不一致说明该数据被其他的事务进行操作了，此时就**再次来过**，重新执行该操作；反之，数据没有改动，直接将**新数据放到内存中**

**检测过程==CAS（Compare And Swap）**

**CAS指令是硬件支持的操作。**

CAS顾名思义就是，比较并且交换，其步骤就是上面说的检测过程。

1. 进行数据操作
2. 进行比较
3. 数据没有改动，直接进行提交
4. 反之，数据改动，再次来过，重新执行该操作

如下图：

<img src="https://ykitty.oss-cn-beijing.aliyuncs.com/photo/%E5%85%B6%E4%BB%96/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/CAS.png"/>

## 4. 悲观锁和乐观锁的特点

### 4.1 悲观锁

1. 效率低下，每次都需要加锁，获得锁资源
2. 数据安全性好，不会出现，脏读，不可重复读以及幻读等问题
3. 读的并发性低

### 4.2 乐观锁

1. 效率高，每次都直接对数据进行操作
2. 数据安全性不够，尤其当数据处于频繁修改的情况下
3. 对于读多写少，可以提高系统的吞吐量

## 5. 悲观锁和乐观锁的使用场景

### 5.1 悲观锁

1. 用于**数据频繁被修改**的情况下。比如：数据库的行锁和表锁
2. **一个操作的步骤比较多**的情况下，每次**回滚**时，代价比较大
3. **写操作远大于读操作**的情景

### 5.2 乐观锁 

1. **数据不频繁修改**。比如：进行版本迭代的时候，更新版本号
2. 对于一个数据**读操作远远多于写操作**的情景

综上所述：

**悲观锁**适合**写多读少**的，也就是**强一致性**的场景；**乐观锁**适合**写多读少**的，**并发冲突少**的场景

## 6. 悲观锁和乐观锁的实现方式

### 6.1 悲观锁实现方式

悲观锁的实现依赖于**数据库提供的锁机制**。

悲观锁的流程：

1. 再对记录进行修改之前，先尝试为其加上**排它锁**
2. 如果加锁失败，说明该记录正在被修改，那么当前操作需要进行等待或者抛异常
3. 加锁成功，对该数据进行操作，操作完成释放锁
4. 再次期间如果有其他数据想要操作数据或者添加排它锁，会等待我们解锁或者抛异常

### 6.2 乐观锁实现方式

乐观锁的实现不需要数据库锁机制

乐观锁操作主要有两个步骤：**冲突检测，数据更新**。实现方式比较典型的一种就是**CAS**。具体可以参考上面讲的。

对于CAS实现方式会出现一个问题。那就是**ABA问题**。

举例：线程A拿出数据是2，对其进行修改，要将变成3，此时线程B也拿出数据2，并且将其改成3之后，然后再改回到2，线程B执行结束，线程A去进行冲突检测的时候，就会检测到数据没有发生改变，认为此时正确，但是此时已经数据被其他的线程修改过了。**尽管线程A的CAS没有错误，但是不代表这个过程没有问题。**

#### 6.2.1 解决ABA问题

使用一个可以单独**递增的version字段**。

乐观锁在每次进行数据的修改的时候都会带上一个version字段。进行比较的时候不仅仅只是数据的比较，同时也要比较verison，**version一致执行操作并且对version进行++**，否则错误重新执行。

因为每次操作是version都会++，所以不会出现ABA问题，因为**version只增不减**

除了使用version外，也可以使用**时间戳**。因为**时间戳也是具有递增属性**

## 7. 悲观锁和乐观锁应该如何选择

乐观锁并没真正加锁，效率高，更新失败的概率高。

悲观锁使用数据锁机制，效率低，更新失败的概率低。

由于现在互联网的**三高机制（高并发，高性能，高可用）**，所以一般使用的都是**乐观锁**