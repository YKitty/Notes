# 乐观锁和悲观锁

---------------------

## 前言

**悲观锁和乐观锁**是两种常见的**资源并发锁**设计思路，也是**并发编程**中的一个基础概念。

本文是以**数据库环境**下进行介绍。

## 1. 并发控制

在**多线程环境下，为了保证线程安全，需要使用并发控制。**

数据库管理系统中有**事务**的概念，它是**一组操作**，并且满足**ACID特性**。一个事务可以看成一组**任务**，而任务是由**线程驱动**的，因此事务也可以并发的执行。并发执行多个事务时，为了保证每个事物都具有ACID特性，也同样需要**并发控制**。

常见的由并发所产生的问题：

- **脏读：** 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，此时，另外一个事务也访问这个数据，然后使用了这个数据

- **不可重复读：** 是指在一个事务内，多次读同一个数据。在这个事务还没有结束时，另外一个事务也访问同一个数据。那么，在第一个事务两次读取数据之间，另外一个事务的修改，那么第一个事务两次读到的数据可能是不一样的。

- **幻读：** 指当事务不是独立执行时发生的一种现象（一般是对于整个表进行了修改）。

  例如：第一个事务对一个表的所有id进行了修改，同时第二个事务也向这个表中插入一行新数据。那么以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就像发生了幻觉一样。

## 2. 乐观锁和悲观锁的出现的原因

为了**解决并发**带来的问题。我们引入了**并发控制**。

主要有两种并发控制方法：**悲观并发控制（悲观锁）和乐观并发控制（乐观锁）**。

## 3. 乐观锁和悲观锁是什么

### 3.1 并发控制机制

**悲观锁：** 假定每次操作时，都会发生并发冲突，每次进行操作时，都会申请锁

**乐观锁：** 假定每次操作时，都不会发生冲突，直接进行操作，操作完成之后进行**冲突检测**，发生冲突，则申请锁重新操作，否则操作成功。

**【注意】：乐观锁不能解决脏读问题**

原因：对于乐观锁操作完成之后，会进行冲突检测，但是这个时候第二事务有可能还**没有进行回滚操作**，所以就无法检测到，**数据是否冲突**

### 3.2 悲观并发控制（悲观锁）

**悲观并发控制**保持**悲观态度**，认为并发执行过程中**一定会出现问题**，一定要对数据进行保护，需要提前申请锁资源，不能同时两个事务对同一个数据进行操作。

因此，**悲观锁**就是每次一个事务在进行操作时一定要先**获得锁资源**然后才能操作数据（临界资源），当没有活的锁资源的时候，就不能对数据进行操作

### 3.3 乐观并发控制（乐观锁）

**乐观并发控制**保持**乐观态度**，认为在并发过程中**一般都不会出现问题**，可以**直接对数据进行操作**，不需要提前申请锁资源。

但是对于乐观锁有着一个机制就是每次对于数据操作完成之后不会立即对于操作的数据进行提交，会经过一个**检测过程**。

**检测过程：**对于数据修改之后，会将**旧数据和现内存中的数据进行比较**，如果数据不一致说明该数据被其他的事务进行操作了，此时就**再次来过**，重新执行该操作；反之，数据没有改动，直接将**新数据放到内存中**

**检测过程==CAS（Compare And Swap）**

**CAS指令是硬件支持的操作。**

CAS顾名思义就是，比较并且交换，其步骤就是上面说的检测过程。

1. 进行数据操作
2. 进行比较
3. 数据没有改动，直接进行提交
4. 反之，数据改动，再次来过，重新执行该操作

如下图：

<img src="https://ykitty.oss-cn-beijing.aliyuncs.com/photo/%E5%85%B6%E4%BB%96/%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/CAS.png"/>

## 4. 悲观锁和乐观锁的特点

### 4.1 悲观锁

1. 效率低下，每次都需要加锁，获得锁资源
2. 数据安全性好，不会出现，脏读，不可重复读以及幻读等问题
3. 读的并发性低

### 4.2 乐观锁

1. 效率高，每次都直接对数据进行操作
2. 数据安全性不够，尤其当数据处于频繁修改的情况下
3. 对于读多写少，可以提高系统的吞吐量

## 5. 悲观锁和乐观锁的使用场景

### 5.1 悲观锁

1. 用于**数据频繁被修改**的情况下。比如：数据库的行锁和表锁
2. **一个操作的步骤比较多**的情况下，每次**回滚**时，代价比较大
3. **写操作远大于读操作**的情景

### 5.2 乐观锁 

1. **数据不频繁修改**。比如：进行版本迭代的时候，更新版本号
2. 对于一个数据**读操作远远多于写操作**的情景

综上所述：

**悲观锁**适合**写多读少**的，也就是**强一致性**的场景；**乐观锁**适合**写多读少**的，**并发冲突少**的场景