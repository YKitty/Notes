# 死锁

---------

## 1. 死锁产生的原因

当**两个或者多个进程（线程）**在执行的过程中，两个进程已经拥有**一份资源（资源是不可被掠夺的）**了，并且想**申请其他进程（线程）已经拥有的资源**。

由于资源是不可掠夺的，所以另一个进行进程想要获得这份资源必须等待该进程将这份资源释放，导致两个进程一直在等待另一个进程释放资源，均无法获得新的资源。从而产生死锁情况。

如图：

![](https://ykitty.oss-cn-beijing.aliyuncs.com/photo/%E5%85%B6%E4%BB%96/%E6%AD%BB%E9%94%81/%E6%AD%BB%E9%94%81.png)

从上图可以看出，进程A为了获得资源B，等待进程B释放资源B；同时进程B为了获得资源A等待进程A释放资源A。但是资源是不可释放的，从而导致进程A和进程B都一直处于等待的状态，陷入循环。

## 2. 死锁的产生四个条件

1. **互斥**，对于一个资源是互斥的只能同时被一个进程或者线程所拥有
2. **请求与保持**，一个进程一个拥有了一个资源之后，并且请求其他的资源
3. **不可掠夺**，一个资源是不可被其他进程或者线程掠夺的
4. **循环等待**，所有申请资源的进程或者线程，形成了一个环状，均在等待其下一个进程或者线程的资源

如图：

![](https://ykitty.oss-cn-beijing.aliyuncs.com/photo/%E5%85%B6%E4%BB%96/%E6%AD%BB%E9%94%81/%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85.png)

如图，所有的进程和线程形成一个环状结构，均在等待下一个进程或者线程所拥有的资源，从而导致，所有的进程或者线程均处于等待状态。

**当符合上述的四个条件的时候，就构成了死锁**

## 3. 死锁的缺点

1. 一个程序执行起来之后，产生了死锁之后，就会导致程序陷入死循环，无法跳出程序从而崩溃
2. 会导致资源无法释放，产生内存泄露的问题。

## 4. 如何解决死锁问题

解决死锁问题主要有着两大类的思想：

1. **提前预防死锁**的产生。在写代码的时候，就细心注意，不让死锁的情况发生
2. 产生死锁后，**破坏死锁产生的四个必要条件**。

- **破坏互斥条件**

**一份资源被两个进程（线程）所拥有**。**一般不这样做**，这样做的话，会导致管理权转移的情况。比如：C++上的**auto_ptr（智能指针）**，在进行拷贝构造或者赋值运算的时候，就会产生这样的问题。一份资源被两个进程所拥有，但是当其中一个进程（线程）将资源释放之后，另一个进程（线程）的资源变为无效的资源，出现错误。

- **破坏请求与保持条件**

**一个进程（线程）申请资源的时候，一次将所需要的资源全部申请**。不会当需要的时候再去申请，就不会发生去抢夺其他进程或者线程的资源了

- **破坏不可掠夺条件**

当发生死锁时，选择一个代价最小的进程，将其所拥有的资源全部释放。

- **破坏循环等待条件**

**给资源进行编号，进程只能按照编号顺序来获得资源。**也就是获得资源时，只能获得当前处于第一个位置的资源，已经被获得的资源无法再去获取。

## 5. 死锁检测和恢复

**超时机制和判断是否存在环路**。从而判断是否存在死锁。

在检测到死锁时，采用**进程回退或者事务回滚**等机制，释放资源，之后程序正常执行。

**InnoDB存储引擎**采用的就是**是否存在环路**来判断是否存在死锁，并且采用**事务回滚**的方式来进行死锁恢复。

## 6. 活锁与饥饿

**活锁：**多个进程（线程）一直在释放资源给其他进程，导致资源在进程之间循环走，但是无法被进程（线程）获得

**饥饿：**对于每个进程都有着一个优先级编号，当多个进程获得同一份资源时，总是优先级高的进程获得资源，优先级低的进程无法获得资源，直到高优先级的进程释放资源。此时低优先级的进程获取不到资源就是饥饿。